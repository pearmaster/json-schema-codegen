{%-import 'constraints.jinja2' as constraint-%}
{%-if schema.type == 'integer'-%}
    {%-if schema.format is defined and schema.format == 'uint64'-%}
        {%-set rjtype = 'uint64'-%}
    {%-elif schema.format is defined and schema.format == 'int64'-%}
        {%-set rjtype = 'int64'-%}
    {%-else-%}
        {%-set rjtype = 'int'-%}
    {%-endif-%}
{%-else%}
    {%-set rjtype = 'double'-%}
{%-endif-%}
{%-if schema.type == 'integer'-%}
    {%-if schema.format is defined and schema.format == 'uint64'-%}
        {%-set cpptype = 'uint64_t'-%}
    {%-elif schema.format is defined and schema.format == 'int64'-%}
        {%-set cpptype = 'int64_t'-%}
    {%-else-%}
        {%-set cpptype = 'int'-%}
    {%-endif-%}
{%-else-%}
    {%-set cpptype = 'double'-%}
{%-endif-%}
{%-set std = "std::" %}
{%-set className = namer.get_object_name(uri, path)%}
{%-set exception %}{{ namer.get_util_namespace("JsonSchemaException") | join("::") }}{%endset%}
{%if schema.const is not defined%}
{{className}}::{{Name}}({{cpptype}} value)
{
    Set(value);
}
{%endif%}
{%-if schema.default is defined or schema.const is defined%}
{%set emptyConstructor = true %}
{{className}}::{{Name}}()
{
    Set({%-if schema.const is defined-%}{{constraint.ExprName('const')}}{%-else-%}{{constraint.ExprName('default')}}{%-endif-%});
}
{%-endif%}

{{className}}::operator {{cpptype}}() const
{
    return Get();
}

{{className}}& {{className}}::operator=({{cpptype}} value)
{
    Set(value);
    return *this;
}
{%for ns in namer.get_namespace(uri, path) %}
namespace {{ns}} {
{%-endfor%} 
{{std}}ostream& operator<<({{std}}ostream& os, const {{className}}& num)
{
    os << num._value;
    return os;
}

bool operator< (const {{className}}& left, const {{className}}& right)
{
    return left._value < right._value;
}

{{std}}size_t hash_value(const {{className}}& num)
{
    return boost::hash_value(num._value);
}
{%for _ in namer.get_namespace(uri, path) %}}{%-endfor%} // end namespaces

{{className}}& {{className}}::Set({{cpptype}} value)
{
    Validate(value);
    _value = value;
    return *this;
}

{{cpptype}} {{className}}::Get() const
{
    return _value;
}

void {{className}}::Validate({{cpptype}} testValue)
{
    {%-if schema.minimum is defined %}
    if (testValue < {{constraint.ExprName('minimum')}}) throw {{exception}}("Value was less than {{schema.minimum}}");
    {%-endif%}
    {%-if schema.exclusiveMinimum is defined %}
    if (testValue <= {{constraint.ExprName('exclusiveMinimum')}}) throw {{exception}}("Value was less than or equal to {{schema.exclusiveMinimum}}");
    {%-endif%}
    {%-if schema.maximum is defined %}
    if (testValue > {{constraint.ExprName('maximum')}}) throw {{exception}}("Value was more than {{schema.maximum}}");
    {%-endif%}
    {%-if schema.exclusiveMaximum is defined %}
    if (testValue >= {{constraint.ExprName('exclusiveMaximum')}}) throw {{exception}}("Value was less than or equal to {{schema.exclusiveMaximum}}");
    {%-endif%}
    {%-if schema.multipleOf is defined %}
    if ((testValue % {{constraint.ExprName('multipleOf')}}) != 0) throw {{exception}}("Value was not a multiple of {{schema.multipleOf}}");
    {%-endif%}
    {%-if schema.const is defined%}
    if (testValue != {{constraint.ExprName('const')}}) throw {{exception}}("Value was not {{schema.const}}");
    {%-endif%}
}

{{className}} {{className}}::FromJson(const rapidjson::Value& json)
{
    if (!(json.Is{{rjtype == 'double' and 'Number' or rjtype | UpperCamelCase}}()))
    {
        throw {{exception}}("Wasn't a{%if rjtype.startswith('i') or rjtype.startswith('u')%}n{%endif%} {{rjtype}}");
    }

    {{className}} newObject(json.Get{{rjtype | UpperCamelCase}}());
    return newObject;
}

{{className}} {{className}}::FromString(const {{std}}string& str)
{
    return {{className}}(boost::lexical_cast<{{cpptype}}>(str));
}

void {{className}}::ToJson(rapidjson::Value& value, rapidjson::Value::AllocatorType& allocator) const
{
    value.Set{{rjtype | UpperCamelCase}}(_value);
}
