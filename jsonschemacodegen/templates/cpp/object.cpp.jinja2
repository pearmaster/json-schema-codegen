{%import 'loader.jinja2' as loader with context-%}
{%-import 'propname.jinja2' as helper-%}

{%-set exception %}{{ namer.get_util_namespace("JsonSchemaException") | join("::") }}{%endset%}
{%-set exceptionCollection %}{{ namer.get_util_namespace("JsonSchemaExceptionCollection") | join("::") }}{%endset%}

{%macro NestedObjectNameOnly(name) -%}
    {%-if name|UpperCamelCase != Name|UpperCamelCase%}{{-name | UpperCamelCase-}}{%else%}{{name | UpperCamelCase}}Property{%endif-%}
{%-endmacro%}
{%macro NestedObjectName(name) -%}
    {{className}}::{{NestedObjectNameOnly(name)}}
{%-endmacro%}
{%-macro ObjectType(propName, propSchema) -%}
    {%-if '$ref' in propSchema -%}
        {{-namer.get_object_name(uri, propSchema['$ref']) -}}
    {%-else-%}
        {{-NestedObjectName(propName)-}}
    {%-endif-%}
{%-endmacro%}
{%-set additionalProperties = ('additionalProperties' not in schema or not schema['additionalProperties'])%}

{%-for propName, propSchema in schema.RequiredList() %}
{{-loader.SubClass('cpp', NestedObjectName(propName), NestedObjectNameOnly(propName), propSchema)}}
{%-endfor%}
{%-for propName, propSchema in schema.UnRequiredList() %}
{{-loader.SubClass('cpp', NestedObjectName(propName), NestedObjectNameOnly(propName), propSchema)}}
{%-endfor%}

{%if schema.RequiredList() | length > 0 %}
{{className}}::{{Name}}(
    {%-for propName, propSchema in schema.RequiredList()-%}
        const {{ObjectType(propName, propSchema)}}& {{propName | camelCase}}{%if not loop.last%}, {%endif%}
    {%-endfor%}){{' : '}}
    {%-for propName, propSchema in schema.RequiredList()-%}
        {{propName|privatize}}({{propName | camelCase}}){%if not loop.last%}, {%endif%}
    {%-endfor%}
{

}
{%else%}
{{className}}::{{Name}}()
{

}

{%-if schema['properties'] | length == 1 %}
{%-set propName = schema.PropertyKeys()[0] %}
{%-set propSchema = schema.PropertyValues()[0] %}
{{className}}::{{Name}}(const {{ObjectType(propName, propSchema)}}& {{propName | camelCase}}) : {{propName|privatize}}({{propName | camelCase}})
{

}
{%-endif%}
{%if 'type' in propSchema and propSchema['type'] in ['boolean', 'integer', 'number'] %}
{{className}}::{{Name}}({{ {"boolean":"bool", "integer":"int", "number":"double"}[propSchema.type] }} {{propName | camelCase}}) : {{Name}}({{ObjectType(propName, propSchema)}}({{propName | camelCase}}))
{

}
{%-elif 'type' in propSchema and propSchema['type'] == 'string'-%}
{{className}}::{{Name}}(const std::string& {{propName | camelCase}}) : {{Name}}({{ObjectType(propName, propSchema)}}::FromString({{propName | camelCase}}))
{

}
{%-endif%} {# propschema type #}
{%endif%}

{%-for propName, propSchema in schema.properties.items() %}
{%-if propName in schema.required%}

{{ObjectType(propName, propSchema)}} {{className}}::Get{{propName | UpperCamelCase}}() const
{
    return {{propName | privatize}};
}

{{ObjectType(propName, propSchema)}}& {{className}}::Get{{propName | UpperCamelCase}}Reference()
{
    return {{propName | privatize}};
}

{{className}}& {{className}}::Set{{propName | UpperCamelCase}}(const {{ObjectType(propName, propSchema)}}& value)
{
    {{propName | privatize}} = value;
    return *this;
}
{%else%}
boost::optional<{{ObjectType(propName, propSchema)}}> {{className}}::Get{{propName | UpperCamelCase}}() const
{
    return {{propName | privatize}};
}

{{className}}& {{className}}::Set{{propName | UpperCamelCase}}(const {{ObjectType(propName, propSchema)}}& value)
{
    {{propName | privatize}} = value;
    return *this;
}
{%endif%}
{%-endfor%}

{{className}} {{className}}::FromJson(const rapidjson::Value& json)
{
    if (!(json.IsObject()))
    {
        throw {{exception}}("JSON wasn't an object");
    }
    {##}
    {{exceptionCollection}} exceptionCollection;
    {%for propName, propSchema in schema.RequiredList()-%}
    boost::optional<{{ObjectType(propName, propSchema)}}> optLocal{{propName | UpperCamelCase}};
    if (!json.HasMember({{helper.ConstPropertyName(propName)}}))
    {
        exceptionCollection.AddException({{exception}}("Property is missing", {{helper.ConstPropertyName(propName)}}));
    }
    else
    {
        try
        {
            optLocal{{propName | UpperCamelCase}} = {{ObjectType(propName, propSchema)}}::FromJson(json[{{helper.ConstPropertyName(propName)}}]);
        }
        catch (const {{exception}}& e)
        {
            exceptionCollection.AddException(e, {{helper.ConstPropertyName(propName)}});
        }
        catch (const {{exceptionCollection}}& ec)
        {
            exceptionCollection.AddException(ec, {{helper.ConstPropertyName(propName)}});
        }
        catch (const std::exception& e)
        {
            exceptionCollection.AddException({{exception}}(e), {{helper.ConstPropertyName(propName)}});
        }
    }
    {%endfor%}
    boost::optional<{{className}}> optNewInstance;
    {%-if schema.RequiredList() %}
    if ({%for propName, propSchema in schema.RequiredList()%}optLocal{{propName | UpperCamelCase}}{%if not loop.last%} && {%endif%}{%endfor%})
    {
        optNewInstance = {{className}}({%for propName, propSchema in schema.RequiredList()%}*optLocal{{propName | UpperCamelCase}}{%if not loop.last%}, {%endif%}{%endfor%});
    }
    {%else%}
    // Yes I know this looks weird to create a boost::optional only to immediately instantiate it.
    // However, this is generated code, and there is a branch you don't see here where we conditionally instantiate it.
    optNewInstance = {{className}}();
    {%-endif%}
    {%-for propName, propSchema in schema.UnRequiredList()%}
    if (json.HasMember({{helper.ConstPropertyName(propName)}}))
    {
        try
        {
            auto local{{propName | UpperCamelCase}} = {{ObjectType(propName, propSchema)}}::FromJson(json[{{helper.ConstPropertyName(propName)}}]);
            if (optNewInstance)
            {
                optNewInstance->Set{{propName | UpperCamelCase}}(local{{propName | UpperCamelCase}});
            }
        }
        catch (const {{exception}}& e)
        {
            exceptionCollection.AddException(e, {{helper.ConstPropertyName(propName)}});
        }
        catch (const {{exceptionCollection}}& ec)
        {
            exceptionCollection.AddException(ec, {{helper.ConstPropertyName(propName)}});
        }
        catch (const std::exception& e)
        {
            exceptionCollection.AddException({{exception}}(e), {{helper.ConstPropertyName(propName)}});
        }
    }
    {%-endfor%}
    if (exceptionCollection.IsExceptional() || !optNewInstance)
    {
        throw exceptionCollection;
    }
    return *optNewInstance;
}

void {{className}}::ToJson(rapidjson::Value& value, rapidjson::Value::AllocatorType& allocator) const
{
    if (!value.IsObject())
    {
        value.SetObject();
    }
    {%if flase and additionalProperties %}
    for (const auto &i : _additionalProperties)
    {
        value.AddMember(i->first, i->second);
    }
    {%endif%}
    {%-for propName, propSchema in schema.properties.items() %}
    {%-if propName in schema.required%}
    rapidjson::Value temp{{propName|UpperCamelCase}};
    {{propName|privatize}}.ToJson(temp{{propName|UpperCamelCase}}, allocator);
    value.AddMember(rapidjson::StringRef({{helper.ConstPropertyName(propName)}}), temp{{propName|UpperCamelCase}}, allocator);
    {%else%}
    if ({{propName|privatize}})
    {
        rapidjson::Value temp{{propName|UpperCamelCase}};
        {{propName|privatize}}->ToJson(temp{{propName|UpperCamelCase}}, allocator);
        value.AddMember(rapidjson::StringRef({{helper.ConstPropertyName(propName)}}), temp{{propName|UpperCamelCase}}, allocator);
    }
    {%endif%}
    {%-endfor%}
}
