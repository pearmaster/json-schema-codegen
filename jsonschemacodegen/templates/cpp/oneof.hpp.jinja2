{%-import 'loader.jinja2' as loader-%}
{%-set exception %}{{resolver.cpp_get_lib_ns() | join('::')}}::JsonSchemaException{%endset%}
{%macro NestedObjectName(name) -%}
    {{-name | UpperCamelCase-}}
{%-endmacro%}
{%-macro ObjectType(propName, propSchema) -%}
    {%-if '$ref' in propSchema -%}
        {{-loader.Reference(resolver, propSchema['$ref'])-}}
    {%-else-%}
        {{-NestedObjectName(propName)-}}
    {%-endif-%}
{%-endmacro%}
{%-set optionList -%}
{%-if schema.allow_none-%}boost::blank, {%endif-%} 
{%-for s in schema.GetComponents() -%}{%set optionName%}Option{{loop.index}}{%endset-%}
{{ObjectType(optionName, s)}}{%if not loop.last%}, {%endif-%}
{%-endfor -%}
{%-endset%}
/*! {{Name}} is a wrapper around one of {{schema.GetComponents()|length}} different types.
 {%-if schema.description %}
 *
 {{schema.description | indent(1) }}

 Sub-Types:
 {%for s in schema.GetComponents() %}{%set optionName%}Option{{loop.index}}{%endset-%}
   - `{{ObjectType(optionName, s)}}` {{s.Resolve(resolver).title}}
 {%endfor%}
 *
 {%-endif%}
 */
class {{Name}}
{
public:
    {%-for s in schema.GetComponents() %}{%set optionName%}Option{{loop.index}}{%endset%}
    {{loader.Class('hpp', resolver, [Name], optionName, s) | indent(4) }}
    
    {%endfor%}

    {%-if schema.allow_none-%}
    /*! Constructor where no value is needed for initialization.
     */
    {{Name}}();
    {%-endif-%}

    {%-for s in schema.GetComponents() %}{%set optionName%}Option{{loop.index}}{%endset%}
    /*! Constructor that initializes the {{Name}} object with a {{ObjectType(optionName, s)}} instance.]
     */
    {{Name}}(const {{ObjectType(optionName, s)}}& obj);
    {%endfor%}
    virtual ~{{Name}}() = default;

    {%-set commonType = schema.GetCommonType(resolver)%}
    {%-if commonType in ['boolean', 'integer', 'number', string] %}
    /*! Stream operator.
    */
    friend std::ostream& operator<<(std::ostream& os, const {{Name}}& inst);
    {%-endif%}

    /*! Produce a hash value of the object.
     * \param inst A {{Name}} instance from which to produce a hash.
     * \return a hash number using a boost hashing algorithm.
     */
    friend std::size_t hash_value(const {{Name}}& inst);

    /*! Gets a variant object containing whatever instance of whatever object has been set.
     */
    boost::variant<{{optionList}}> Get() const;

    /*! Sets the variant object.
     * \fn void Set(const boost::variant<{{optionList}}>& variant)
     * \param variant  An instance of one of these types must be passed: {{optionList}}
     */
    void Set(const boost::variant<{{optionList}}>& variant);
    {# #}
    {%-if commonType in ['boolean', 'integer', 'number', string] %}
    /*! Gets the value of as an {{commonType}} regardless of the actual variant type.
     *
     * This object was generated from a `oneOf` JSON-Schema object, which specifies that the value must match exactly 1 of the sub-types.  We don't verify that a value would not match multiple subtypes as defined in the schema.  If the schema incorrectly allowed this, we will match against the first sub-type match.
     *
     * \return {{commonType}} value
     */
    {{ {'boolean':'bool', 'integer':'int', 'number':'float', string:'std::string'}[commonType] }} GetAs{{commonType|UpperCamelCase}}() const;

    {%if commonType == 'integer'%}
    /*! Uses the integer value to create a new {{Name}} instance.
     *
     * \param value This value must conform to one of the variant types.
     * \return new {{Name}} instance.
     */
    static {{Name}} FromInteger(int value);
    {%endif%}
    /*! Performs a "lexical cast" on the string to create a new {{Name}} object.
     *
     * \param str stringified representation of a {{schema.GetCommonType(resolver)}}.
     * \throw {{exception}} If the string cannot be cast or does not JSON-schema validate.
     * \returns New instance of {{Name}}.
     */
    static {{Name}} FromString(const std::string& str);
    {%-endif%}

    /*! \fn {{Name}} FromJson(const rapidjson::Value& json)
     * \brief Deserializes a JSON value into a new instance of {{Name}}.
     * \param json is the RapidJSON value.
     * \throw {{exception}} If the JSON didn't validate according to the schema of one of the component objects.
     * \returns {{Name}}
     */
    static {{Name}} FromJson(const rapidjson::Value& json);

    /*! \fn ToJson(rapidjson::Value& value, rapidjson::Value::AllocatorType& allocator)
     * \brief Sets 'value' to whatever variant object is set
     * \param value is the RapidJSON value which will be modified to contain the serialization
     * \param allocator is the top-level RapidJSON document allocator which may be used for allocations
     */
    void ToJson(rapidjson::Value& value, rapidjson::Value::AllocatorType& allocator) const;

    /*! Sets a string handle associated with this {{Name}} instance.
     * This gets called by a parent object after creating an instance that is used for an object's property.
     * \param handle is the string name.
     */
    void SetHandle(const std::string& handle);

    /*! Gets the string handle associated with this {{Name}} instance.
     * This is often the property name used in a JSON-object parent.
     * It may be empty.
     * \returns the handle string
     */
    std::string GetHandle() const;
private:
    boost::variant<{{optionList}}> _value;
    std::string _handle;
};
